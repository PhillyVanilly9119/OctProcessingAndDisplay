""" This script allows for generation of single-file-binaries 
for each volume generated by an unpacked volume series from the >octhdf2png< tool """

import os
import glob
import imageio
import numpy as np
import matplotlib.pyplot as plt # debug
from PIL import Image
from tqdm import tqdm
from natsort import natsorted


def generate_volumes(path_loading: str, path_saving: str):
    # check if path for saving exists and create it if it does not 
    if not os.path.exists(path_saving):
        os.makedirs(path_saving)
    # get list of files in dir
    full_file_list = glob.glob(path_loading + "/*.png")
    # sort list after image numbers (natural sort)
    sorted_full_file_list = natsorted(full_file_list, key=lambda y: y.lower())
    # get dims of volumes by loading first image
    im = imageio.imread(sorted_full_file_list[0])
    dims = (im.shape[1], im.shape[0], im.shape[0]) # (a,b,c) 
    # assert len(sorted_full_file_list) % dims[-1] == 0, "Existing file size and expected volume size mismatch" # TODO: check if this could blow up...
    print(f"[INFO:] Volumes in this folder have dimensions {dims} (a,b,c) - expecting and stiching {len(sorted_full_file_list) // dims[-1]} volumes")
    vol_buffer = np.zeros(shape=dims, dtype=np.uint8) # allocate np-array/volume buffer
    vol_counter = 0
    for i, val in tqdm(enumerate(sorted_full_file_list)):
        c_idx = i % dims[-1] # c-scan index to avoid indexing errors
        if os.path.getsize(val) < 4:
            continue
        im = np.swapaxes(np.asarray(imageio.imread(val), dtype=np.uint8), 0, 1) # load image
        vol_buffer[:,:,c_idx] = im # write current B-scan in volume
        if c_idx == dims[-1] - 1: # enters, every time one entire volume full
            # save volume as binary
            # print(f"\n[INFO:] Saving volume No.{vol_counter}\n") #debug
            vol_time_stamp = os.path.basename(path_saving)
            file_name = "OctVolume_" + str(vol_counter) + "_" + vol_time_stamp + "_" + str(dims[0]) + "x" + str(dims[1]) + "x" + str(dims[-1]) + ".bin"
            vol_buffer.tofile(os.path.join(path_saving, file_name))
            # save en face image as png
            enface = np.mean(vol_buffer, axis=0)
            enface = enface * 255 / np.max(enface) # map input to uint8 dynamic range
            imageio.imwrite(os.path.join(path_saving, file_name.split('.bin')[0] + ".png"), np.uint8(enface))
            vol_counter += 1    


def run():
    
    # path = r"C:\Users\PhilippsLabLaptop\Desktop\VolumeSeries"
    # path_loading = glob.glob(path + "/*")
    # path_saving = [path + "_binaries" for path in path_loading]
    
    path_loading = [
        r"C:\Users\phili\Desktop\PhillyScripts\20230411_135910_Slammer1"
        ]
    
    path_saving = [i + '_binaries' for i in path_loading]
    
    for i, _ in enumerate(path_loading):
        generate_volumes(path_loading[i], path_saving[i])


if "__main__" == __name__:
    run()
